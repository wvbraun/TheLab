Introduction

A class is a group of related methods and variables. A class
describes these things, and in most cases, you create an 
instance of this class, now refered to as an object. On this
object, you use the defined methods and variables. 

=============================================================================================
Properties

Properties allow you to control the accessibility of a classes
variables, and is the recommended way to access variables from
the outside. 

A property is much like a combination of a variable and a 
method -- It cannot take any parameters, but you are able
to process the value before it is assigned to our returned. 
A propety consists of 2 parts, a get and set method, wrapped
inside the propert:

	private string color;

	public string Color
	{
		get { return color; }
		set { color = value; }
	}

The get method should return the variable, while the set 
method should assign a value to it. Another thing about
properties is that only one method is required -- either
get or set, the other is optional. This allows you to define
read-only and write-only properties:

	public string Color
	{
		get
		{
			return color.ToUpper();
		}

		set
		{
			if (value == "Red")
				color = value;
			else
				Console.WriteLine("This car can only be red!");
		}
	}


=============================================================================================
Constructors and Destructors

Constructors are special methods, used when instantiating a 
class. A constructor can never return anything, which is
why you do not have to define a return type for it. 

A normal method is defined like this:
	
	public string Describe();

A constructor can be defined like this:
	
	public Car();


Constructors can be overloaded as well, meaning we can 
have multiple constructors with the same name, but different
parameters:

	public Car() {}

	public Car(string color)
	{
		this.color = color;
	}


A constructor can call another constructor:

	public Car()
	{
		Console.WriteLine("Constructor with no paramters called first!");
	}

	public Car(string color) : this()
	{
		this.color = color;
		Console.WriteLine("Constructor with color paramter called next!");
	}


If the constructor you wish to call takes paramters, you can 
do that as well:

	public Car(string color) : this()
	{
		this.color = color;
		Console.WriteLine("Constructor with color paramter called!");
	}

	public Car(string param1, string param2) : this(param1)
	{

	}

If you call the constructor which takes 2 parameters, the first
parameter will be used to invoke the constructor that takes
1 parameter.

=============================================================================================
Destructors

Since C# is garbage collected, meaning that the framework will
free the objects that you no longer use, there may be times 
where you need to do some manual cleanup. 

A destructor, a method called once an object is disposed, 
can be used to cleanup resources used by the object. 

Here is an example of a destructor for our Car class:

	~Car()
	{
		Console.WriteLine("Out..");
	}

=============================================================================================
Method Overloading

You may wish to add functionality to an existing function,
which requires one or more parameters to be added. By doing so,
you would break existing code calling this function, since they
would now not be passing the required amount of parameters. To
work around this, you could define the newly added parameters
as optional, and give them a default value that corresponds
to how the code would work before adding the parameters. 

Method overloading allows the programmer to define several
methods with the same name, as long as they take a different
set of parameters. 

An example of this is the Substring() method of the String
class. It is with an extra overloadlike this:

	string Substring(int startIndex);
	string Substring(int startIndex, int Length);

You can call it with either one or two parameters. If you
call it with only one, the length parameter is assumed to be
the rest of the string. 

=============================================================================================
Visibility

The visibility of a class, a method, a variable, or a property
tells us how this item can be accessed. The most common types
of visibility are private and public:


	public - The member can be reached from anywhere. This is
			 the least restrictive visibility. Enums and 
			 interfaces are, by default, publicy visble.

	protected - Members can only be reached from within the
	  	 		same class, or form a class which inherits this
	  	 		class.

	internal - Members can be reached from within the same 
			   project only.

	protected internal - The same as internal, except that also
						 classes which inherits from this class
						 can reach its members, even from another
						 project.

	private - Can only be reached by members from the same class. 
			  This is the most restrictive. Classes and structs
			  are by default set to private visibility. 


So for instance, if you have two classes, Class1 and Class2, 
private members from Class1 can only be used within Class1. 
You cannot create a new instance of Class1 inside of Class2.

If Class2 inherits from Class1, then only non-private members
can be reached from inside of Class2. 
	

=============================================================================================
Static Members

The usual way to communicate with a class is to create a new
instance of the class, and then work on the resulting object.
In most casses, this is what classes are all about -- the 
ability to instantiate multiple copies of the same class and
then use them differnently in some way. However, in some 
cases, you might like to have a class which you may use
without instantiating it, or at least a class where you can 
use members of it without creating an object for it. 

For instance, you may have a class with a variable that always
remains the same, no matter where and how it is used. This is
called a static member. 

A class can be static, and it can have static members, both
functions and fields. A static class cannot be instatiated,
so in other words, it will work more as a group of related
objects than an actual class. You may choose to create a 
non-static class instead, but let it have certain static 
members. A non-static class can still be instantiated and used
like a regular class, but you cannot used a static member
or an object of the class. A static class may ONLY contain
static members. 

Example:

	public static class Rectangle
	{
		public static int CalcArea(int w, int h)
		{
			return w * h;
		}
	}

To use this method, we call it directly on the class:

	Console.WriteLine("Area: {0}", Rectangle.CalcArea(5,4));


=============================================================================================
Inheritance

Inheritance is the ability to create classes which inherit
certain aspects from parent classes. A simple number is an 
instance of a class, which inherits from the System.Object
class. 

Example:
	
	public class Animal
	{
		public void Greet()
		{
			Console.WriteLine("Hello!");
		}
	}

	public class Dog : Animal {}


	Animal animal = new Animal();
	animal.Greet();
	Dog dog = new Dog();
	dog.Greet();


If we wanted to customize the greeting:

	public class Animal
	{
		public virtual void Greet()
		{
			Console.WriteLine("Hello, I am an animal!");
		}
	}

	public class Dog : Animal 
	{
		public override void Greet()
		{
			Console.WriteLine("Hello, I am a dog!");
		}
	}


In order to override a member of a class, you must mark
the member as virtual. 

=============================================================================================
Abstract Classes

Abstract classes are typically used to define a base class
in the hierachy. What is special about them is that you 
cannot create an instance of them. Instead, you must subclass
them, and create an instance of your subclass. 

=============================================================================================
Interfaces

Interfaces are similar to abstract classes and they share
the fact that no instances of them can be created. However,
interfaces are more conceptual than abstract classes, since 
not method bodies are allowed at all. So an interface is kind
of like an abstract class with nothing but abstract methods,
and since there are no methods with actual code, there is no
need for any fields. Properties are allowed though, as well
as indexers and evens. You can consider an interface as a 
contract - a class that implements it is required to implement
all of the methods and properites. 
