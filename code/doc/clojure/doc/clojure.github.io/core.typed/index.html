<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
    <title>clojure.core.typed - Gradual Typing 0.2.22 API documentation</title>
    <link href="static/favicon.png" rel="icon" />
    <link href="static/favicon.png" rel="shortcut icon" />
    <link media="all" type="text/css" href="static/clojure.css" rel="stylesheet" />
    <link media="all" type="text/css" href="static/wiki.css" rel="stylesheet" />
    <link media="all" type="text/css" href="static/internal.css" rel="stylesheet" />
    <style>.menuWrapper{height: 36px;}</style>
  </head>
<!--
This document was auto-generated from the source by the clojure autodoc system.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
-->
  <body>
    <div id="AllContentContainer">
      <div id="Header">
	<a id="Logo" href="index.html"><img alt="Clojure" height="100" width="100" src="static/clojure-icon.gif" /></a>
	<h1><a title="page header title" id="page-header" href="index.html">core.typed API Reference</a></h1>
      </div>
      <div id="leftcolumn"><div style="text-align: center;"></div>
<div class="menu">
  <div class="WikiCustomNav WikiElement wiki">
    <span class="toc-header"><span id="project-name">Gradual Typing</span> <span id="version">0.2.22</span> API</span><br />
    <ul>
      <li><a class="wiki_link" href="index.html">Overview</a></li>
      <li><a class="wiki_link" href="api-index.html">API Index</a></li>
    </ul>
    
    
    <a href="http://clojure.org" class="wiki_link">Clojure Home</a>
  </div>
</div>
</div>
      <div id="rightcolumn">
	<div id="Content">
	  <div class="contentBox"><div class="innerContentBox">
              <div id="content_view" class="wiki wikiPage">
                <div id="right-sidebar"><div id="toc">
  <h1 class="nopad">Table of Contents</h1>
  <div style="margin-left: 1em;" class="toc-section">
    <a href="#toc0" style="margin-top: 3px;">Overview</a>
    
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#" style="margin-top: 3px;"></a>
    
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#" style="margin-top: 3px;"></a>
    
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#var-section" style="margin-top: 3px;">Vars and Functions</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/*collect-on-eval*">*collect-on-eval*</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/*verbose-forms*">*verbose-forms*</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/*verbose-types*">*verbose-types*</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/AnyInteger">AnyInteger</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Atom1">Atom1</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Coll">Coll</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/EmptyCount">EmptyCount</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/EmptySeqable">EmptySeqable</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Hierarchy">Hierarchy</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Id">Id</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Int">Int</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Keyword">Keyword</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Map">Map</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Nilable">Nilable</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/NilableNonEmptySeq">NilableNonEmptySeq</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/NonEmptyColl">NonEmptyColl</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/NonEmptyCount">NonEmptyCount</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/NonEmptyLazySeq">NonEmptyLazySeq</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/NonEmptySeq">NonEmptySeq</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/NonEmptySeqable">NonEmptySeqable</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/NonEmptyVec">NonEmptyVec</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Num">Num</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Option">Option</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Ref1">Ref1</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Seq">Seq</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Seqable">Seqable</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Set">Set</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/SortedSet">SortedSet</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Symbol">Symbol</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Var1">Var1</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Vec">Vec</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ann">ann</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ann-datatype">ann-datatype</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ann-form">ann-form</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ann-many">ann-many</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ann-precord">ann-precord</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ann-protocol">ann-protocol</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ann-record">ann-record</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/atom&gt;">atom&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/cf">cf</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/check-form*">check-form*</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/check-form-info">check-form-info</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/check-ns">check-ns</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/check-ns-info">check-ns-info</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/declare-alias-kind">declare-alias-kind</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/declare-datatypes">declare-datatypes</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/declare-names">declare-names</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/declare-protocols">declare-protocols</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/def-alias">def-alias</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/def&gt;">def&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/defn&gt;">defn&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/doseq&gt;">doseq&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/dotimes&gt;">dotimes&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/fn&gt;">fn&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/for&gt;">for&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/inst">inst</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/inst-ctor">inst-ctor</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/into-array&gt;">into-array&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/letfn&gt;">letfn&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/load-if-needed">load-if-needed</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/loop&gt;">loop&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/method-type">method-type</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/nilable-param">nilable-param</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/non-nil-return">non-nil-return</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/override-constructor">override-constructor</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/override-method">override-method</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/pfn&gt;">pfn&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/print-env">print-env</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/print-filterset">print-filterset</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ref&gt;">ref&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/reset-caches">reset-caches</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/statistics">statistics</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/tc-ignore">tc-ignore</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/typed-deps">typed-deps</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/var-coverage">var-coverage</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/var&gt;">var&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/warn-on-unannotated-vars">warn-on-unannotated-vars</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/when-let-fail">when-let-fail</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.core.typed.async" style="margin-top: 3px;">clojure.core.typed.async</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.async/Buffer">Buffer</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.async/Chan">Chan</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.async/Port">Port</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.async/ReadOnlyChan">ReadOnlyChan</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.async/ReadOnlyPort">ReadOnlyPort</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.async/TimeoutChan">TimeoutChan</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.async/WriteOnlyPort">WriteOnlyPort</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.async/buffer&gt;">buffer&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.async/chan&gt;">chan&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.async/dropping-buffer&gt;">dropping-buffer&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.async/go&gt;">go&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.async/sliding-buffer&gt;">sliding-buffer&gt;</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.core.typed.hole" style="margin-top: 3px;">clojure.core.typed.hole</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.hole/NoisyHole">NoisyHole</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.hole/-&gt;NoisyHole">-&gt;NoisyHole</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.hole/noisy-hole">noisy-hole</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.hole/silent-hole">silent-hole</a>
      
    </div>
  </div>
</div>
</div>
                <div id="content-tag"><h1 id="overview">API for <span id="clojure.core.typed">clojure.core.typed</span>
  - <span id="header-project">Gradual Typing</span> <span id="header-version">0.2.22</span><span id="header-status-block"> (<span id="header-status">in development</span>)</span>
  </h1>

<br />Full namespace name: <span id="long-name">clojure.core.typed</span>
<p></p>
<h2>Overview</h2>
<div id="home-page">Project home page is <a href="http://github.com/clojure/core.typed/">http://github.com/clojure/core.typed/</a></div>
<pre id="namespace-docstr"></pre>


<br />



<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/*collect-on-eval*">*collect-on-eval*</h2>
    <span id="var-type">dynamic var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">If a true value, global annotations are collected by the
type checker when their respective forms are evaluated (eg. ann).</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L930" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/*verbose-forms*">*verbose-forms*</h2>
    <span id="var-type">dynamic var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">If true, print complete forms in error messages. Bind
around a type checking form like cf or check-ns.

eg.
(binding [*verbose-forms* true]
  (cf ['deep ['deep ['deep ['deep]]]] Number))
;=&gt; &lt;full form in error&gt;</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L1355" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/*verbose-types*">*verbose-types*</h2>
    <span id="var-type">dynamic var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">If true, print fully qualified types in error messages
and return values. Bind around a type checking form like 
cf or check-ns.

eg. 
(binding [*verbose-types* true] 
  (cf 1 Number))
;=&gt; java.lang.Number</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L1342" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/AnyInteger">AnyInteger</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: AnyInteger
</pre>
    <pre id="var-docstr">A type that returns true for clojure.core/integer?

(U Integer Long clojure.lang.BigInt BigInteger Short Byte)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Atom1">Atom1</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Atom1 t)
</pre>
    <pre id="var-docstr">An atom that can read and write type x.

(TFn [[x :variance :invariant]] (Atom x x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Coll">Coll</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Coll t)
</pre>
    <pre id="var-docstr">A persistent collection with member type x.

(TFn [[x :variance :covariant]] (IPersistentCollection x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/EmptyCount">EmptyCount</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: EmptyCount
</pre>
    <pre id="var-docstr">The type of all things with count 0. Use as part of an intersection.
eg. See EmptySeqable.

(ExactCount 0)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/EmptySeqable">EmptySeqable</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (EmptySeqable t)
</pre>
    <pre id="var-docstr">A type that can be used to create a sequence of member type x
with count 0.

(TFn [[x :variance :covariant]] (I (Seqable x) (ExactCount 0)))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Hierarchy">Hierarchy</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Hierarchy
</pre>
    <pre id="var-docstr">A hierarchy for use with derive, isa? etc.

'{:parents (IPersistentMap Any Any),
  :ancestors (IPersistentMap Any Any),
  :descendants (IPersistentMap Any Any)}</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Id">Id</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Id
</pre>
    <pre id="var-docstr">The identity function at the type level.

(TFn [[x :variance :covariant]] x)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Int">Int</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Int
</pre>
    <pre id="var-docstr">A type that returns true for clojure.core/integer?

(U Integer Long clojure.lang.BigInt BigInteger Short Byte)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Keyword">Keyword</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Keyword
</pre>
    <pre id="var-docstr">A keyword

clojure.lang.Keyword</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Map">Map</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Map t t)
</pre>
    <pre id="var-docstr">A persistent map with keys k and vals v.

(TFn
 [[k :variance :covariant] [v :variance :covariant]]
 (IPersistentMap k v))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Nilable">Nilable</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Nilable t)
</pre>
    <pre id="var-docstr">A union of x and nil.

(TFn [[x :variance :covariant]] (U nil x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NilableNonEmptySeq">NilableNonEmptySeq</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (NilableNonEmptySeq t)
</pre>
    <pre id="var-docstr">A persistent sequence of member type x with count greater than 0, or nil.

(TFn [[x :variance :covariant]] (U nil (I (ISeq x) (CountRange 1))))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NonEmptyColl">NonEmptyColl</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (NonEmptyColl t)
</pre>
    <pre id="var-docstr">A persistent collection with member type x and count greater than 0.

(TFn
 [[x :variance :covariant]]
 (I (IPersistentCollection x) (CountRange 1)))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NonEmptyCount">NonEmptyCount</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: NonEmptyCount
</pre>
    <pre id="var-docstr">The type of all things with count greater than 0. Use as part of an intersection.
eg. See NonEmptySeq

(CountRange 1)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NonEmptyLazySeq">NonEmptyLazySeq</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (NonEmptyLazySeq t)
</pre>
    <pre id="var-docstr">A non-empty lazy sequence of type t

(TFn [[t :variance :covariant]] (I (LazySeq t) (CountRange 1)))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NonEmptySeq">NonEmptySeq</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (NonEmptySeq t)
</pre>
    <pre id="var-docstr">A persistent sequence of member type x with count greater than 0.

(TFn [[x :variance :covariant]] (I (ISeq x) (CountRange 1)))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NonEmptySeqable">NonEmptySeqable</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (NonEmptySeqable t)
</pre>
    <pre id="var-docstr">A type that can be used to create a sequence of member type x
with count greater than 0.

(TFn [[x :variance :covariant]] (I (Seqable x) (CountRange 1)))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NonEmptyVec">NonEmptyVec</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (NonEmptyVec t)
</pre>
    <pre id="var-docstr">A persistent vector with member type x and count greater than 0.

(TFn
 [[x :variance :covariant]]
 (I (IPersistentVector x) (CountRange 1)))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Num">Num</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Num
</pre>
    <pre id="var-docstr">A type that returns true for clojure.core/number?

Number</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Option">Option</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Option t)
</pre>
    <pre id="var-docstr">A union of x and nil.

(TFn [[x :variance :covariant]] (U nil x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Ref1">Ref1</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Ref1 t)
</pre>
    <pre id="var-docstr">A ref that can read and write type x.

(TFn [[x :variance :invariant]] (IRef x x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Seq">Seq</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Seq t)
</pre>
    <pre id="var-docstr">A persistent sequence of member type x.

(TFn [[x :variance :covariant]] (ISeq x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Seqable">Seqable</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Seqable t)
</pre>
    <pre id="var-docstr">A type that can be used to create a sequence of member type x.

(TFn [[x :variance :covariant]] (Seqable x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Set">Set</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Set t)
</pre>
    <pre id="var-docstr">A persistent set with member type x

(TFn [[x :variance :covariant]] (IPersistentSet x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/SortedSet">SortedSet</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (SortedSet t)
</pre>
    <pre id="var-docstr">A sorted persistent set with member type x

(TFn [[x :variance :covariant]] (Extends [(IPersistentSet x) Sorted]))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Symbol">Symbol</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Symbol
</pre>
    <pre id="var-docstr">A symbol

clojure.lang.Symbol</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Var1">Var1</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Var1 t)
</pre>
    <pre id="var-docstr">An var that can read and write type x.

(TFn [[x :variance :invariant]] (Var x x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Vec">Vec</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Vec t)
</pre>
    <pre id="var-docstr">A persistent vector with member type x.

(TFn [[x :variance :covariant]] (IPersistentVector x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann">ann</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann varsym typesyn)
</pre>
    <pre id="var-docstr">Annotate varsym with type. If unqualified, qualify in the current namespace.
If varsym has metadata {:no-check true}, ignore definitions of varsym 
while type checking.

If annotating vars in namespaces other than the current one, a fully
qualified symbol must be provided. Note that namespace aliases are not
recognised: the *full* namespace must be given in the first part of the symbol.

eg. ; annotate the var foo in this namespace
    (ann foo [Number -&gt; Number])

    ; annotate a var in another namespace
    (ann another.ns/bar [-&gt; nil])
 
    ; don't check this var
    (ann ^:no-check foobar [Integer -&gt; String])</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L888" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-datatype">ann-datatype</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-datatype dname [field :- type*] opts*)
       (ann-datatype binder dname [field :- type*] opts*)
</pre>
    <pre id="var-docstr">Annotate datatype Class name dname with expected fields.
If unqualified, qualify in the current namespace.
Takes an optional type variable binder before the name.

Fields must be specified in the same order as presented 
in deftype, with exactly the same field names.

Also annotates datatype factories and constructors.

Binder is a vector of specs. Each spec is a vector
with the variable name as the first entry, followed by
keyword arguments:
- :variance (mandatory)
  The declared variance of the type variable. Possible
  values are :covariant, :contravariant and :invariant.
- :&lt; (optional)
  The upper type bound of the type variable. Defaults to
  Any, or the most general type of the same rank as the
  lower bound.
- :&gt; (optional)
  The lower type bound of the type variable. Defaults to
  Nothing, or the least general type of the same rank as the
  upper bound.

eg. ; a datatype in the current namespace
    (ann-datatype MyDatatype [a :- Number,
                              b :- Long])

    ; a datatype in another namespace
    (ann-datatype another.ns.TheirDatatype
                  [str :- String,
                   vec :- (Vec Number)])

    ; a datatype, polymorphic in a
    (ann-datatype [[a :variance :covariant]]
                  MyPolyDatatype
                  [str :- String,
                   vec :- (Vec Number)])</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L946" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-form">ann-form</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-form form ty)
</pre>
    <pre id="var-docstr">Annotate a form with an expected type.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L770" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-many">ann-many</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-many t &amp; vs)
</pre>
    <pre id="var-docstr">Annotate several vars with type t.

eg. (ann-many FakeSearch
              web1 web2 image1 image2 video1 video2)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L920" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-precord">ann-precord</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-precord dname vbnd fields &amp; {ancests :unchecked-ancestors, rplc :replace, :as opt})
</pre>
    <pre id="var-docstr">Annotate record Class name dname with a polymorphic binder and expected fields.
If unqualified, qualify in the current namespace.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L1090" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-protocol">ann-protocol</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-protocol vbnd varsym &amp; methods)
       (ann-protocol varsym &amp; methods)
</pre>
    <pre id="var-docstr">Annotate a possibly polymorphic protocol var with method types.

eg. (ann-protocol IFoo
      bar
      [IFoo -&gt; Any]
      baz
      [IFoo -&gt; Number])
    (defprotocol&gt; IFoo
      (bar [this])
      (baz [this]))

    ; polymorphic protocol
    ; x is scoped in the methods
    (ann-protocol [[x :variance :covariant]]
      IFooPoly
      bar
      [(IFooPoly x) -&gt; Any]
      baz
      [(IFooPoly x) -&gt; Number])
    (defprotocol&gt; IFooPoly
      (bar [this])
      (baz [this]))</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L1102" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-record">ann-record</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-record dname [field :- type*] opts*)
       (ann-record binder dname [field :- type*] opts*)
</pre>
    <pre id="var-docstr">Annotate record Class name dname with expected fields.
If unqualified, qualify in the current namespace.
Takes an optional type variable binder before the name.

Fields must be specified in the same order as presented 
in defrecord, with exactly the same field names.

Also annotates record factories and constructors.

Binder is a vector of specs. Each spec is a vector
with the variable name as the first entry, followed by
keyword arguments:
- :variance (mandatory)
  The declared variance of the type variable. Possible
  values are :covariant, :contravariant and :invariant.
- :&lt; (optional)
  The upper type bound of the type variable. Defaults to
  Any, or the most general type of the same rank as the
  lower bound.
- :&gt; (optional)
  The lower type bound of the type variable. Defaults to
  Nothing, or the least general type of the same rank as the
  upper bound.

eg. ; a record in the current namespace
    (ann-record MyRecord [a :- Number,
                          b :- Long])

    ; a record in another namespace
    (ann-record another.ns.TheirRecord
                  [str :- String,
                   vec :- (Vec Number)])

    ; a record, polymorphic in a
    (ann-record [[a :variance :covariant]]
                  MyPolyRecord
                  [str :- String,
                   vec :- (Vec Number)])</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L1028" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/atom&gt;">atom&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (atom&gt; t init &amp; args)
</pre>
    <pre id="var-docstr">Like atom, but creates an Atom1 of type t.

Same as (atom (ann-form init t) args*)

eg. (atom&gt; Number 1)
    (atom&gt; (Vec Any) [])</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L1209" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/cf">cf</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (cf form)
       (cf form expected)
</pre>
    <pre id="var-docstr">Takes a form and an optional expected type and
returns a human-readable inferred type for that form.
Throws an exception if type checking fails.

Do not use cf inside a typed namespace. cf is intended to be
used at the REPL or within a unit test. Note that testing for
truthiness is not sufficient to unit test a call to cf, as nil
and false are valid type syntax.

cf preserves annotations from previous calls to check-ns or cf,
and keeps any new ones collected during a cf. This is useful for
debugging and experimentation. cf may be less strict than check-ns
with type checker warnings.

eg. (cf 1) 
    ;=&gt; Long

    (cf #(inc %) [Number -&gt; Number])
    ;=&gt; [Number -&gt; Number]</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L1279" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/check-form*">check-form*</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (check-form* form)
       (check-form* form expected)
       (check-form* form expected type-provided?)
</pre>
    <pre id="var-docstr">Takes a (quoted) form and optional expected type syntax and
type checks the form. If expected is provided, type-provided?
must be true.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L1259" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/check-form-info">check-form-info</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (check-form-info form &amp; {:keys [expected type-provided?]})
</pre>
    <pre id="var-docstr">Alpha - subject to change

Type checks a (quoted) form and returns a map of results from type checking the
form.

Options
- :expected        Type syntax representing the expected type for this form
                   type-provided? option must be true to utilise the type.
- :type-provided?  If true, use the expected type to check the form</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L1413" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/check-ns">check-ns</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (check-ns)
       (check-ns ns-or-syms &amp; {:keys [collect-only trace], :as kw})
</pre>
    <pre id="var-docstr">Type check a namespace/s (a symbol or Namespace, or collection).
If not provided default to current namespace.
Returns a true value if type checking is successful, otherwise
throws an Exception.

Do not use check-ns within a checked namespace.
It is intended to be used at the REPL or within a unit test.
Suggested idiom for clojure.test: (is (check-ns 'your.ns))

check-ns resets annotations collected from 
previous check-ns calls or cf. A successful check-ns call will
preserve any type annotations collect during that checking run.

Keyword arguments:
- :collect-only  if true, collect type annotations but don't type check code.
                 Useful for debugging purposes.

If providing keyword arguments, the namespace to check must be provided
as the first argument.

Bind *verbose-types* to true to print fully qualified types.
Bind *verbose-forms* to print full forms in error messages.

eg. (check-ns 'myns.typed)
    ;=&gt; :ok
   
    ; implicitly check current namespace
    (check-ns)
    ;=&gt; :ok

    ; collect but don't check the current namespace
    (check-ns *ns* :collect-only true)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L1521" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/check-ns-info">check-ns-info</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (check-ns-info)
       (check-ns-info ns-or-syms &amp; {:keys [collect-only trace]})
</pre>
    <pre id="var-docstr">Alpha - subject to change

Same as check-ns, but returns a map of results from type checking the
namespace.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L1448" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/declare-alias-kind">declare-alias-kind</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (declare-alias-kind sym ty)
</pre>
    <pre id="var-docstr">Declare a kind for an alias, similar to declare but on the kind level.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L716" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/declare-datatypes">declare-datatypes</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (declare-datatypes &amp; syms)
</pre>
    <pre id="var-docstr">Declare datatypes, similar to declare but on the type level.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L694" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/declare-names">declare-names</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (declare-names &amp; syms)
</pre>
    <pre id="var-docstr">Declare names, similar to declare but on the type level.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L729" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/declare-protocols">declare-protocols</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (declare-protocols &amp; syms)
</pre>
    <pre id="var-docstr">Declare protocols, similar to declare but on the type level.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L705" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/def-alias">def-alias</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (def-alias sym doc-str t)
       (def-alias sym t)
</pre>
    <pre id="var-docstr">Define a type alias. Takes an optional doc-string as a second
argument.

Updates the corresponding var with documentation.

eg. (def-alias MyAlias
      "Here is my alias"
      (U nil String))</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L740" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/def&gt;">def&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (def&gt; name docstring? :- type expr)
</pre>
    <pre id="var-docstr">Like def, but with annotations.

eg. (def&gt; vname :- Long 1)

;doc
(def&gt; vname
  "Docstring"
  :- Long
  1)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L571" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/defn&gt;">defn&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (defn&gt; name docstring? :- type [param :- type *] exprs*)
       (defn&gt; name docstring? (:- type [param :- type *] exprs*) +)
</pre>
    <pre id="var-docstr">Like defn, but with annotations. Annotations are mandatory for
parameters and for return type.

eg. (defn&gt; fname :- Integer [a :- Number, b :- (U Symbol nil)] ...)

;annotate return
(defn&gt; :- String [a :- String] ...)

;named fn
(defn&gt; fname :- String [a :- String] ...)

;multi-arity
(defn&gt; fname 
  (:- String [a :- String] ...)
  (:- Long   [a :- String, b :- Number] ...))</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L543" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/doseq&gt;">doseq&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (doseq&gt; seq-exprs &amp; body)
</pre>
    <pre id="var-docstr">Like doseq but requires annotation for each loop variable: 
[a [1 2]] becomes [a :- Long [1 2]]

eg.
(doseq&gt; [a :- (U nil AnyInteger) [1 nil 2 3]
         :when a]
   (inc a))</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L297" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/dotimes&gt;">dotimes&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (dotimes&gt; bindings &amp; body)
</pre>
    <pre id="var-docstr">Like dotimes.

eg. (dotimes&gt; [_ 100]
      (println "like normal"))</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L155" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/fn&gt;">fn&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (fn&gt; name? :- type? [param :- type* &amp; param :- type * ?] exprs*)
       (fn&gt; name? (:- type? [param :- type* &amp; param :- type * ?] exprs*) +)
</pre>
    <pre id="var-docstr">Like fn, but with annotations. Annotations are mandatory
for parameters, with optional annotations for return type.
If fn is named, return type annotation is mandatory.

Suggested idiom: use commas between parameter annotation triples.

eg. (fn&gt; [a :- Number, b :- (U Symbol nil)] ...)

    ;annotate return
    (fn&gt; :- String [a :- String] ...)

    ;named fn
    (fn&gt; fname :- String [a :- String] ...)

    ;multi-arity
    (fn&gt; fname 
      (:- String [a :- String] ...)
      (:- Long   [a :- String, b :- Number] ...))</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L499" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/for&gt;">for&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (for&gt; tk ret-ann seq-exprs body-expr)
</pre>
    <pre id="var-docstr">Like for but requires annotation for each loop variable: [a [1 2]] becomes [a :- Long [1 2]]
Also requires annotation for return type.

eg. (for&gt; :- Number
      [a :- (U nil AnyInteger) [1 nil 2 3]
       :when a]
      (inc a))</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L172" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/inst">inst</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (inst inst-of &amp; types)
</pre>
    <pre id="var-docstr">Instantiate a polymorphic type with a number of types.

eg. (inst foo-fn t1 t2 t3 ...)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L120" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/inst-ctor">inst-ctor</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (inst-ctor inst-of &amp; types)
</pre>
    <pre id="var-docstr">Instantiate a call to a constructor with a number of types.
First argument must be an immediate call to a constructor.
Returns exactly the instantiatee (the first argument).

eg. (inst-ctor (PolyCtor. a b c)
               t1 t2 ...)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L127" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/into-array&gt;">into-array&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (into-array&gt; cljt coll)
       (into-array&gt; javat cljt coll)
       (into-array&gt; into-array-syn javat cljt coll)
</pre>
    <pre id="var-docstr">Make a Java array with Java class javat and Typed Clojure type
cljt. Resulting array will be of type javat, but elements of coll must be under
cljt. cljt should be a subtype of javat (the same or more specific).

*Temporary hack*
into-array-syn is exactly the syntax to put as the first argument to into-array.
Calling resolve on this syntax should give the correct class.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L820" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/letfn&gt;">letfn&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (letfn&gt; [fn-spec-or-annotation*] expr*)
</pre>
    <pre id="var-docstr">Like letfn, but each function spec must be annotated.

eg. (letfn&gt; [a :- [Number -&gt; Number]
             (a [b] 2)

             c :- [Symbol -&gt; nil]
             (c [s] nil)]
      ...)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L595" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/load-if-needed">load-if-needed</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (load-if-needed)
</pre>
    <pre id="var-docstr">Load and initialize all of core.typed if not already</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L1382" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/loop&gt;">loop&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (loop&gt; [binding :- type init*] exprs*)
</pre>
    <pre id="var-docstr">Like loop, except loop variables require annotation.

Suggested idiom: use a comma between the type and the initial
expression.

eg. (loop&gt; [a :- Number, 1
            b :- (U nil Number), nil]
      ...)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L648" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/method-type">method-type</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (method-type mname)
</pre>
    <pre id="var-docstr">Given a method symbol, print the core.typed types assigned to it.
Intended for use at the REPL.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L73" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/nilable-param">nilable-param</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (nilable-param msym mmap)
</pre>
    <pre id="var-docstr">Override which parameters in qualified method msym may accept
nilable values. If the parameter is a parameterised type or
an Array, this also declares the parameterised types and the Array type as nilable.

mmap is a map mapping arity parameter number to a set of parameter
positions (integers). If the map contains the key :all then this overrides
other entries. The key can also be :all, which declares all parameters nilable.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L859" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/non-nil-return">non-nil-return</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (non-nil-return msym arities)
</pre>
    <pre id="var-docstr">Override the return type of fully qualified method msym to be non-nil.
Takes a set of relevant arities,
represented by the number of parameters it takes (rest parameter counts as one),
or :all which overrides all arities.

eg. ; must use full class name
    (non-nil-return java.lang.Class/getDeclaredMethod :all)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L842" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/override-constructor">override-constructor</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (override-constructor ctorsym typesyn)
</pre>
    <pre id="var-docstr">Override all constructors for Class ctorsym with type.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L1162" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/override-method">override-method</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (override-method methodsym typesyn)
</pre>
    <pre id="var-docstr">Override type for qualified method methodsym.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L1173" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/pfn&gt;">pfn&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (pfn&gt; &amp; forms)
</pre>
    <pre id="var-docstr">Define a polymorphic typed anonymous function.
(pfn&gt; name? [binder+] :- type? [[param :- type]* &amp; [param :- type *]?] exprs*)
(pfn&gt; name? [binder+] (:- type? [[param :- type]* &amp; [param :- type *]?] exprs*)+)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L483" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/print-env">print-env</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (print-env debug-str)
</pre>
    <pre id="var-docstr">During type checking, print the type environment to *out*,
preceeded by literal string debug-str.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L873" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/print-filterset">print-filterset</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (print-filterset debug-string frm)
</pre>
    <pre id="var-docstr">During type checking, print the filter set attached to form, 
preceeded by literal string debug-string.
Returns nil.

eg. (let [s (seq (get-a-seqable))]
      (print-filterset "Here now" s))</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L98" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ref&gt;">ref&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ref&gt; t init &amp; args)
</pre>
    <pre id="var-docstr">Like ref, but creates a Ref1 of type t.

Same as (ref (ann-form init t) args*)

eg. (ref&gt; Number 1)
    (ref&gt; (Vec Any) [])</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L1219" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/reset-caches">reset-caches</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (reset-caches)
</pre>
    <pre id="var-docstr">Reset internal type caches.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L1400" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/statistics">statistics</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (statistics nsyms)
</pre>
    <pre id="var-docstr">Takes a collection of namespace symbols and returns a map mapping the namespace
symbols to a map of data</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L1574" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/tc-ignore">tc-ignore</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (tc-ignore &amp; body)
</pre>
    <pre id="var-docstr">Ignore forms in body during type checking</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L790" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/typed-deps">typed-deps</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (typed-deps &amp; args)
</pre>
    <pre id="var-docstr">Declare namespaces which should be checked before the current namespace.
Accepts any number of symbols. Only has effect via check-ns.

eg. (typed-deps clojure.core.typed.holes
                myns.types)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L1184" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/var-coverage">var-coverage</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (var-coverage)
       (var-coverage nsyms-or-nsym)
</pre>
    <pre id="var-docstr">Summarises annotated var coverage statistics to *out*
for namespaces nsyms, a collection of symbols or a symbol/namespace.
Defaults to the current namespace if no argument provided.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L1601" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/var&gt;">var&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (var&gt; sym)
</pre>
    <pre id="var-docstr">Like var, but resolves at runtime like ns-resolve and is understood by
the type checker. sym must be fully qualified (without aliases).

eg. (var&gt; clojure.core/+)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L1233" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/warn-on-unannotated-vars">warn-on-unannotated-vars</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (warn-on-unannotated-vars)
</pre>
    <pre id="var-docstr">Allow unannotated vars in the current namespace. 

Emits a warning instead of a type error when checking
a def without a corresponding expected type.

eg. (warn-on-unannotated-vars)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L1247" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/when-let-fail">when-let-fail</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (when-let-fail b &amp; body)
</pre>
    <pre id="var-docstr">Like when-let, but fails if the binding yields a false value.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b24a8b8485272b0ee553964586bccd334f51ed6c/src/main/clojure/clojure/core/typed.clj#L492" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.async">clojure.core.typed.async</h2>
<pre id="namespace-docstr">This namespace contains annotations and helper macros for type
checking core.async code. Ensure clojure.core.async is require'd
before performing type checking.

go
  use go&gt;

chan
  use chan&gt;

buffer
  use buffer&gt; (similar for other buffer constructors)
</pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.async/Buffer">Buffer</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Buffer t)
</pre>
    <pre id="var-docstr">A buffer of type x.

(TFn
 [[x :variance :invariant]]
 (clojure.core.async.impl.protocols/Buffer x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.async/Chan">Chan</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: quote
       [(Chan t)]
</pre>
    <pre id="var-docstr">A core.async channel

(TFn
 [[x :variance :invariant]]
 (Extends
  [(clojure.core.async.impl.protocols/WritePort x)
   (clojure.core.async.impl.protocols/ReadPort x)
   clojure.core.async.impl.protocols/Channel]))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.async/Port">Port</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Port t)
</pre>
    <pre id="var-docstr">A port that can read and write type x

(TFn
 [[x :variance :invariant]]
 (Extends
  [(clojure.core.async.impl.protocols/ReadPort x)
   (clojure.core.async.impl.protocols/WritePort x)]))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.async/ReadOnlyChan">ReadOnlyChan</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: quote
       [(ReadOnlyChan t)]
</pre>
    <pre id="var-docstr">A core.async channel that statically disallows writes.

(TFn
 [[r :variance :covariant]]
 (Extends
  [(clojure.core.async.impl.protocols/WritePort Nothing)
   (clojure.core.async.impl.protocols/ReadPort r)
   clojure.core.async.impl.protocols/Channel]))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.async/ReadOnlyPort">ReadOnlyPort</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (ReadOnlyPort t)
</pre>
    <pre id="var-docstr">A read-only port that can read type x

(TFn
 [[r :variance :covariant]]
 (Extends
  [(clojure.core.async.impl.protocols/ReadPort r)
   (clojure.core.async.impl.protocols/WritePort Nothing)]))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.async/TimeoutChan">TimeoutChan</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: TimeoutChan
</pre>
    <pre id="var-docstr">A timeout channel

(Chan Any)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.async/WriteOnlyPort">WriteOnlyPort</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (WriteOnlyPort t)
</pre>
    <pre id="var-docstr">A write-only port that can write type x

(TFn
 [[x :variance :invariant]]
 (Extends
  [(clojure.core.async.impl.protocols/ReadPort x)
   (clojure.core.async.impl.protocols/WritePort x)]))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.async/buffer&gt;">buffer&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (buffer&gt; t &amp; args)
</pre>
    <pre id="var-docstr">A statically typed core.async buffer. 

(buffer&gt; t ...) creates a buffer that can read and write type t.
Subsequent arguments are passed directly to clojure.core.async/buffer.

Note: (buffer&gt; t ...) is the same as ((inst buffer t) ...)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/1e09597531e797ead73a0bbbfc570499361a8f6b/src/main/clojure/clojure/core/typed/async.clj#L207" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.async/chan&gt;">chan&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (chan&gt; t &amp; args)
</pre>
    <pre id="var-docstr">A statically typed core.async channel. 

(chan&gt; t ...) creates a buffer that can read and write type t.
Subsequent arguments are passed directly to clojure.core.async/chan.

Note: 
(chan&gt; t ...) is the same as ((inst chan t) ...)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/1e09597531e797ead73a0bbbfc570499361a8f6b/src/main/clojure/clojure/core/typed/async.clj#L196" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.async/dropping-buffer&gt;">dropping-buffer&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (dropping-buffer&gt; t &amp; args)
</pre>
    <pre id="var-docstr">A statically typed core.async dropping buffer. 

(dropping-buffer&gt; t ...) creates a dropping buffer that can read and write type t.
Subsequent arguments are passed directly to clojure.core.async/dropping-buffer.

Note: (dropping-buffer&gt; t ...) is the same as ((inst dropping-buffer t) ...)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/1e09597531e797ead73a0bbbfc570499361a8f6b/src/main/clojure/clojure/core/typed/async.clj#L227" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.async/go&gt;">go&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (go&gt; &amp; body)
</pre>
    <pre id="var-docstr">Asynchronously executes the body, returning immediately to the
calling thread. Additionally, any visible calls to &lt;!, &gt;! and alt!/alts!
channel operations within the body will block (if necessary) by
'parking' the calling thread rather than tying up an OS thread (or
the only JS thread when in ClojureScript). Upon completion of the
operation, the body will be resumed.

Returns a channel which will receive the result of the body when
completed</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/1e09597531e797ead73a0bbbfc570499361a8f6b/src/main/clojure/clojure/core/typed/async.clj#L170" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.async/sliding-buffer&gt;">sliding-buffer&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (sliding-buffer&gt; t &amp; args)
</pre>
    <pre id="var-docstr">A statically typed core.async sliding buffer. 

(sliding-buffer&gt; t ...) creates a sliding buffer that can read and write type t.
Subsequent arguments are passed directly to clojure.core.async/sliding-buffer.

Note: (sliding-buffer&gt; t ...) is the same as ((inst sliding-buffer t) ...)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/1e09597531e797ead73a0bbbfc570499361a8f6b/src/main/clojure/clojure/core/typed/async.clj#L217" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.hole">clojure.core.typed.hole</h2>
<pre id="namespace-docstr">This namespace contains easy tools for hole driven development</pre>


<span id="see-also">See also: 
  <span id="see-also-link">
    <a href="http://matthew.brecknell.net/post/hole-driven-haskell/">Hole Driven Development</a>
  </span><br />
</span><br />

<div id="type-section">
  <p></p>
  <h2>Types</h2>
  <div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.hole/NoisyHole">NoisyHole</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces"></span><br />
  </div>
</div>
<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.hole/-&gt;NoisyHole">-&gt;NoisyHole</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;NoisyHole)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.typed.hole.NoisyHole.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/1e09597531e797ead73a0bbbfc570499361a8f6b/src/main/clojure/clojure/core/typed/hole.clj#L19" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.hole/noisy-hole">noisy-hole</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (noisy-hole)
</pre>
    <pre id="var-docstr">A noisy hole. The type system will complain when
(noisy-hole) is used in positions that expect a type
more specific than Object or Any.
Use (noisy-hole) as a placeholder for code.
Throws an exception when evaluted.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/1e09597531e797ead73a0bbbfc570499361a8f6b/src/main/clojure/clojure/core/typed/hole.clj#L23" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.hole/silent-hole">silent-hole</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (silent-hole)
</pre>
    <pre id="var-docstr">A silent hole. (silent-hole) passes for any other type
when type checking.
Use (silent-hole) as a placeholder for code.
Throws an exception when evaluted.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/1e09597531e797ead73a0bbbfc570499361a8f6b/src/main/clojure/clojure/core/typed/hole.clj#L9" id="var-source">Source</a>
  </div>
</div>


</div>
              </div>
            </div>
          </div>
	</div>
	<div id="foot">
	  <div style="text-align: center;" id="copyright">Copyright 2007-2013 by Rich Hickey and the various contributors</div>
	</div>
      </div>
      <div id="DesignedBy">Logo &amp; site design by <a title="Visit Tom Hickey's website." href="http://www.tomhickey.com">Tom Hickey</a>.<br />
      Clojure auto-documentation system by Tom Faulhaber.</div>
    </div>
    <!-- /AllContentContainer -->
  </body>

</html>