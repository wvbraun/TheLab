Clojure provides the collection types list, vector, set and map. All of them are immutable,
heterogeneous and persitent. Being immutable means that their contents cannot be changed.
Being heterogeneous means that they can hold any kind of object. Being persitent means that
old versions are preserved when new version are created. 

--------------------------------------------------------------------------------------------
The count function returns the number of items in any collection:

(count [19 "yellow" true]) ; => 3

------------
The reverse function returns a sequence of the items in the collection in reverse order:

(reverse [2 4 7]) ; => (7 4 2)

-----------
The map function applies a given function that takes one parameter to each item in a collection,
returning a lazy sequencen of the results. If can also apply functions that take more than
one paramter if a collection is supplied for each argument. If those collections contain
different number of items, the items used from each will be those at the beginning up to the
number of items in the smallest collection:

; this adds 3 to its argument
(map #(+ % 3) [2 4 7]) ; => (5, 7, 10)

;adds corresponding items
(map + [2 4 7] [5 6] [1 2 3 4] ; => (8 12)

-----------
The apply function returns the result of a given function when all the items in a given 
collection are used as arguments:

(apply + [2 4 7]) ; => 13 

-----------
There are many functions that retrieve a single item from a collection:

(def stooges ["moe" "larry" "curly" "shemp"])
(first stooges) ; => "moe"
(second stooges) ; => "larry"
(last stooges) ; => "shemp"
(nth stooges 2) ; indexes start at 0 => "curly"


There are many functions that retrieve several items froma collection:

(next stooges) ; => ("larry" "curly" "shemp")
(butlast stooges) ; => ("moe" "larry" "curly")
(drop-last 2 stooges) ; => ("moe" "larry")

;get names containing more than 3 characters
(filter #(> (count %) 3) stooges) ; => ("larry" "curly" "shemp")
(nthnext stooges 2) ; => ("curly" "shemp")

--------------
There are several predicate functions that test the items in a collection and have a boolean
result. These "short circuit" so they only evalute as many items as necessary:

(every? #(instance? String %) stooges) ; => true
(not-every? #(instance? String %) stooges) ; => false
(some #(instance? Number %) stooges) ; => nil
(not-any? #(instance? Number %) stooges) ; => true

----------------------------------------------------------------------------------------------
Lists -
	Lists are ordered collections of items. They are ideal when new items will be added to 
	or removed from the front(constant-time). They are not efficient (linear time) for 
	finding items by index (using nth) and there is not efficient way to change items by
	inded. 

Here are some ways to create a list that all have the same result:

(def stooges (list "moe" "larry" "curly"))
(def stooges (quote ("moe" "larry" "curly")))
(def stooges '("moe" "larry" "curly"))


-----
The some function can be used to determine if a collection contains a given item. It takes
a predicate function and a collection. Searching a list for a single item is a linear
operation. Usinga set instead of a list is more effiecnt and easier... 

(some #(= % "moe") stooges) ; => true
(some #(= % "mark") stooges) ; => nil

another approach is to create a set from the list and then use the contains? function:

(contains? (set stooges) "moe") ; => true

-----------
Both the conj and cons functions create a new list that contains additional items added to
the front. The remove function creates a new list containing only the items for which a 
predicate function returns false:

(def more-stooges (conj stooges "shemp")) ; => ("shemp" "moe" "larry" "curly")
(def less-stooges (remove #(= % "curly") more-stooges)) ; => ("shemp" "moe" "larry")

------
The into function creates a new list that contains all the items in two lists:

(def kids-of-mike '("greg" "peter" "bobby"))
(def kids-of-carol '("marcia" "jan" "cindy"))
(def brady-bunch (into kids-of-mike kids-of-carol))
(println brady-bunch) ; => (cindy jan marcia greg peter bobby)

------
The peek and pop functions can be used to treat a list as a stack. They operate on the 
beginning, or head, of the list. 

---------------------------------------------------------------------------------------------
Vectors - 
	An ordered collection of items. They are ideal when new items will be added to or removed
	from the back (constant-time). This means that using conj is more efficient than using 
	cons. They are efficient (constant-time) for finding (using nth) or changing (using assoc)
	items by index. Function definitions specify their parameter list using a vector.

Ex:

(def stooges (vector "moe" "larry" "curly"))
(def stooges ["moe" "larry" "curly"])

-----------
Unless the list charactersist of being more effiecient at adding to or removing from the
front is signifcant for a given use, vectors are typically preferred over lists. 

The get function retrieves an item from a vector by index. It takes an optional value to 
be returned if the index is out of range. If this is not supplied and the index is out of
range, it returns nil:

(get stooges 1 "unknown") ; => "larry"
(get stooges 3 "unknown") ; => "unknown"

-----
The assoc function operates on vectors and maps. When applied to a vector, it creates a new
vector where the item specified by an index is replaced. If the index is equal to the number
of items in the vector, a new item is added to the end. If it is grater than the number of
items in the vector, an IndexOutOfBoundsException is thrown: 

(assoc stooges 2 "shemp") ; => ["moe" "larry" "shemp"]

-----
The subvec function returns a new vector that is a subset of an existing one that retains 
the order of the items. It takes a vector, a start index and an optional end index. If the
end index is ommited, the subset runs to the end. The new vector shares the structure of the
original one. 

All the code examples for lists also work for vectors. 


-------------------------------------------------------------------------------------------
Sets - 
	Sets are collections of unique items. They are preferred over lists and vectors when 
	duplicates are not allowed and items do not need to be maintained in the order in which
	they were added. Clojure supports 2 kinds of sets, unsorted and sorted. If the items 
	being added to a sorted set cannot be compared to each other, a ClassCastException is
	thrown.

Ex:

(def stooges (hash-set "moe" "larry" "curly")) ; not sorted
(def stooges #{"moe" "larry" "curly"}) ; not sorted 
(def stooges (sorted-set "moe" "larry" "curly"))

----
The contains? function operates on sets and maps. When used on a set, it determines whether
the set contains a given item. This is much simpler than using the some function which is
needed to test this is a list or vector:

(contains? stooges "moe") ; => true
(contains? stooges "mark) ; => false 

----
Sets can beused as functions of their items. When used in this way, they return the item or
nil. This provides an even more compact way to test whether a set contains a given item:

(stooges "moe") ; => "moe"
(stooges "mark") ; => nil 
(println (if (stooges person) "stooge" "regular person"))

-----
The conj and into functions also work with sets. The location where the items are added is 
only defined for sorted sets. 

The disj function creates a new set where one or more itesm are removed:

(def more-stooges (conj stooges "shemp")) ; => #{"moe" "larry" "curly" "shemp"}
(def less-stooges (disj more-stooges "curly")) ; => #{"moe" "larry" "shemp"}

-----------------------------------------------------------------------------------------
Maps - 
	Maps store associations between keys and their corresponding values where both can be 
	any kind of object. Often keywords are used for map keys. Entries can be stored in 
	such a way that the pairs can be quickly retrieved in sorted order based on their keys. 

Here are some ways to create maps that store assocations form popsicle colors to their 
flavors where the keys and values are both kewords. The commas aid readability. They are
optional and are treated as whitespace.

(def popsicle-map
 (hash-map :red :cherry, :green :apple, :purple :grape))

(def popsicle-map
 {:red :cherry :green :apple :purple :grape}) 

(def popsicle-map 
 (sorted-map :red :cherry, :green :apple, :purple :grape))

---------
Maps can be used as function of their keys. Also, in some cases keys can be used as function
of maps. For example, keyword keys can, but string and integer keys cannot. The following are
valid ways to get the flavor of green popsicles:

(get popsicle-map :green)
(popsicle-map :green)
(:green popsicle-map)

--------
The contains? function operates on sets and maps. When used on a map, it determines wheter
the map contains a given key. The keys function returns a sequence containg all the keys
in a given map. The vals function returns a sequence containing all the values in a given
map:

(contains? popsicle-map :green) ; => true
(keys popsicle-map) ; => (:red :green :purple)
(vals popsicle-map) ; => (:cherry :apple :grape)

-------
The assoc function operates on maps and vectors. When applied to a map, it creates a new
map where any number of key/value pairs are added. Values for existing keys are replaced
by new values:


(assoc popsicle-map :green :lime :blue :blueberry) 
; => {:blue :blueberry, :green :lime, :purple :grape, :red :cherry}

The dissoc funtion takes a map and any number of keys. It returns a new map where those
keys are removed. Specified keys that are not in the map are ignored:

(dissoc popsicle-map :green :blue) ; => {:purple :grape, :red :cherry}

-----------------
When used in the contex of a sequence, maps are treated like a sequence of 
clojure.lang.MapEntry objects. This can be combined with the use of doseq and destructing 
to easily iterate through all the keys and values. The following iterates through all the 
key/value pairs in popsicle-map and binds the key to color and the value to flavor, the 
name function returns the string name of a keyword:

(doseq [[color flavor] popsicle-map]
 (println (str "The flavor of " (name color)
  " popsicles is " (name flavor) ".")))

=> The flavor of green popsicles is apple.
=> The flavor of purple popsicles is grape.
=> The flavor of red popsicles is cherry

-----
The select-keys funciton takes a map and a sequence of keys. It returns a new map where
only those keys are in tha mp. Specified keys that are not in the map are ignored:

(select-keys popsicle-map [:red :green :blue]) ; => {:green :apple, :red :cherry}

-----
The conj function adds all the key/value pairs from one map to another. If any keys in the 
source map alrady exists in the target map, the target map values are replaced by the 
corresponding source map value. 

Values in maps can be maps, and they can be nested to any depth. To demonstrate this 
we will create a map that describes a person, it has a key whose value describes their 
address using a map. It also has a key whose value describes their employer which has its
own address map. 

(def person {
 :name "Mark Volkmann"
 :address {
 	:street "644 Glen Summit"
 	:city "St. Charles"
 	:state "Missouri"
 	:zip 63304}
 :employer {
 	:name "Object Computing, Inc."
 	:address {
 		:street "12140 Woodcrest Executive Dr, Suite 250"
 		:city "Creeve Couer"
 		:state "Missouri"
 		:zip 63141}}})

The get-in function takes a map and a key sequence. It returns the value of the nested
map key as the end of the sequence. The -> macro and the reduce function can also be used
for this purpose. These retrieve the emplyer city which is "creeve coeur"

(get-in person [:employer :address :city]) 
(-> person :employer :address :city)
(reduce get person [:employer :address :city]) 
(
The -> macro, referred to as the 'thread' macro, calls a series of functions, passing
the result of each asn argument to the next:

(f1 (f2 (f3 x)))
(-> x f3 f2 f1)

The reduce functions takes a function of two arguments, an optional value and a collection. 
It begins by calling the function with either the value and the first item in the collection,
or the first two items in the collection if the value is omitted. It then calls the function
repeatedly with the previous function result and the next item in the collection
until every item in teh collection has been processed. 

-------
The assoc-in function takes a map, a key sequence and a new value. It returns a new map 
where the nested map key at the end of the sequence has the new value. For example, 
a new map where the employer city is changed to 'clayton':

(assoc-in person [:employer :address :city] "Clayton")


---
The update-in function takes a map, a key sequence, a function, and any number of 
additional arguments. The function is passed the old value of the key at the end of the 
sequence and the additional arugmentss. The value it returns is used as the new value of 
that key. For example, a new mape where the employer zip code is changed to a string in 
the u.s. "Zip + 4" format:

(update-in person [:employer :address :zip] str "-1234") 
