Suppose 'expr' is an expression containing the variable 'var'. We 
would like 'var' to have the value 'val' when we evaluate 'expr'. 
For example, we might like 'x' to have the value 2 when we evaluate
(+ x 3). or we might want y to have value 3 when we evaluate 
(+ 2 y). The following examples demonstrate this using 'let':

(let ((x 2)) ; let x = 2
 (+ x 3))  	 ; then x + 3 = 5
=> 5 

(let ((y 3))
 (+ 2 y)) 
=> 5

(let ((x 2) (y 3))
 (+ x y))
=> 5

-------------------------------------------------
The general form of a let expression is:

(let ((var val) ...) exp1 exp2 ...)

A let expression is often used to simplify an expression that would
contain two identical subexpressions. Doing so also ensures that the
value of the common subexpression is computed only once. 

(+ (* 4 4) (* 4 4)) 
=> 32 

(let ((a (* 4 4))) ; (var[a] val[* 4 4]) meaning a = 16
 (+ a a)) 		   
=> 32

(let ((list1 '(a b c)) (list2 '(d e f)))
 (cons (cons (car list1)
 			 (car list2))
 	   (cons (car (cdr list1))
 	   	     (car (cdr list2)))))
=> ((a . d) b . e)

Since expressions in the first position of a procedure application
are evaluated no differently from other expressions, a let-bound
variable may also be used:

(let ((f +))
 (f 2 3))
=> 5 

(let ((f +) (x 2))
 (f x 3))
=> 5

(let ((f +) (x 2) (y 3))
 (f x y))
=> 5 

The variables bound by let are visible only within the body of 
the let:

(let ((+ *))
 (+ 2 3))
=> 6

(+ 2 3) 
=> 5 

It is possible to nest let expressions:

(let ((a 4) (b -3))
 (let ((a-squared (* a a))
 	   (b-squared (* b b)))
  (+ a-squared b-squared)))
=> 25

When nested let expressions bind the same variable, only the 
binding created by the inner let is visible with the body.

(let ((x 1))
 (let ((x (+ x 1)))
  (+ x x))) 
=> 4 

The inner binding for x is said to 'shadow' the outer binding. 
A let-bound variable is visible everywhere within the body of its
let expression except where it is shadowed. The region where a 
variable binding is visible is called its 'scope'. The scope of
the first x above is the body of the outer let minus the body of 
the inner let, where it is shadowed by the second x. This form 
of scoping is refered to as 'lexical scoping'. 

Shadowing may be avoided by choosing different names for variables.
The above example could be rewritten so that the variable bound
by the inner let is 'new-x':

(let ((x 1))
 (let ((new-x (+ x 1)))
  (+ new-x new-x)))
=> 4

Although choosing different names can prevent confusion, 
shadowing can help prevent the accidental use of an 'old' value. 

------------------------------------------------------------------
Exercises:

1. Rewrite the following expressions, using let to remove common
subexpression. 

	a. (+ (- (* 3 a) b) (+ (* 3 a) b))
	a) (let (one (* 3 a))
		(+ (- one b) (+ one b))
	

	b. (cons (car (list a b c)) (cdr (list a b c)))
	b) (let (x (list a b c))
		(cons (car x) (cdr x))

2. Determine the value, explain how you derived this value. 

	(let ((x 9)) 			; outer
	 (* x 					; x = 9
	 	(let ((x (/ x 3)))  ; inner, x = 3
	 	 (+ x x))))			; (* 9 (+ 3 3)) 
 	=> 54

3. Rewrite the expressions to give unique names to each different 
let-bound variable so that none of the variables are shadowed. 

	a. (let ((x 'a) (y 'b))
		(list (let ((x 'c)) (cons x y))
			  (let ((y 'd)) (cons x y))))
    a) (let ((x 'a) (y 'b))
    	(list (let ((x-new 'c)) (cons x-new y))
    		  (let ((y-new 'd)) (cons x y-new))))

    b. (let ((x '((a b) c)))
    	(cons (let ((x (cdr x)))
    			(car x))
    		  (let ((x (car x)))
    			(cons (let ((x (cdr x)))
    					(car x))
    				  (cons (let ((x (car x)))
    				  		  x)
    				  		(cdr x))))))
    b) (let ((x '((a b) c)))
    	(cons (let ((x-new (cdr x)))
    			(car x-new))
    		  (let ((x-new-new (car x)))
    		  	(cons (let ((x-new-new-new (cdr x-new-new)))
    		  			(car x-new-new-new))
    		  		 (cons (let ((x-new4 (car x-new-new)))
    		  		 		 x-new4)
    		  		 	   (cdr x-new-new))))))


