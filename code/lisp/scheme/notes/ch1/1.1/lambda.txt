Lambda can be used to create a new procedure that has 'x' as a 
parameter and has the ssame body as the let expression.

(lambda (x) (+x x)) => #<procedure>

The general form of a lambda expression is:

(lambda (var ...) exp1 exp2 ...)

The variables 'var ...' are the formal parameters and the sequence
of exp1 exp2 ... is its body. 

-------------------------
Scheme uses #<procedure> to show that value of an epxression 
is a procedure.

The most common operation to perform ona procedure is to 
apply it to one or more values:

((lambda (x) (+ x x)) (* 3 4))
=> 24

The procedure is the value of (lambda (x) (+ x x)) and the only
argument is the value of (* 3 4). The argument values are bound
to the formal paramters within the body of the lambda expression
in the same way as let-bound variables are bound to their values.
In this case, x is bound to 12. 

Because procedures are objects, we can establisha procedures as
the value of a variable and use the procedure more than once:

(let ((double (lambda (x) (+ x x))))
 (list (double (* 3 4))
 	   (double (/ 99 11))
 	   (double (- 2 7))))
=> (24 18 -10)

Here we establish a bind for double to a procedures, then use this
proceudre to double three different values. 

The procedure expects its actual parameter to be a number, since
it passes the actual paramter onto +. In gener, the actual 
parameter could be any object. For example a similar procedure that
uses cons insead of +. 

(let ((double-cons (lambda (x) (cons x x))))
 (double-cons 'a)) 
=> (a . a)

double and double-cons can be collapsed into a single procedure
by adding an additional argument:

(let ((double-any (lambda (f x) (f x x ))))
 (list (double-any + 13)
 	   (double-any cons 'a)))
=> (26 (a . a))

This demonstrates that the procedures may accept more than one 
argument and that arguments passed to a procedure may themselves
be procedures. 

Ex: lambda nest with let 

(let ((x 'a))
 (let ((f (lambda (y) (list x y))))
  (f 'b)))
=> (a b)

The occurrence of x within the lambda expression refers to the 
x outside the lambda that is bound by the outer let expression. 
The variable x is said to occur free in the lambda expression or 
to be a free variable of the lambda expression. The variable y 
does not occur free in the lambda since it is bound by the lambda
expression. A variable that occurs free in a lambda expression
should be bound by an enclosing lambda or let expression, unless
the variable is bound at top level. 

What happens when the procedure is applied somewhere outside the
scope of the bindings for variables that occur free within the 
procedure, ex:

(let ((f (let ((x 'sam))
			(lambda (y z) (list x y z)))))
 (f 'i 'am))
=> (sam i am)

The same bindings that were in effect when the procedure was 
created are in effect again when the procedure is applied. This
is true even if another binding for x is visible where the 
procedure is applied. 

(let ((f (let ((x 'sam))
			(lambda (y z) (list x y z)))))
 (let ((x 'not-sam))
  (f 'i 'am)))
=> (sam i am)

In both cases, the value of x within the procedure named f 
is sam. 

A let expression is just a direct application of a lambda 
exprssion to a set or argument expressions. 
Ex: These 2 are equivalent

(let ((x 'a)) (cons x x)) == ((lambda (x) (cons x x)) 'a)

A let expression is a syntactic extension defined in terms of
lambda and procedure appliction. 
In general, any expression of the form:

(let ((var val) ...) exp1 exp2 ...)

is equivalent to 

((lambda (var ...) exp1 exp2 ...)

---------------------------------
The formal specification (var ...) can beb any of the 3 forms:

	* a proper list of variables, (var[1] ... var[n]), such
	as we have already seen. 
		- Exactly n actual parameters must be supplied, and
		each variable is bound to the corresponding actual
		parameter. 

	* a single variable, var[r] 
		- Any number of actual paramters is valid; all of the
		actual parameters are put into a single list and the 
		single variable is bound to this list. 

	* an improper list of variables, (var[1] ... var[n] . var[r])
		- At least n actual paramteters must be supplied. 
		The variables var[1] ... var[n] are bound to the 
		corresponding actual parameters, and the variable 
		var[r] is bound to a list containting the remaining
		actual parameters. 

Examples:

1. The arguments are 1, 2, 3, and 4 so the answer is (1 2 3 4)

(let ((f (lambda x x)))
 (f 1 2 3 4))
=> (1 2 3 4)

2. There are no arguments, so empty list. 

(let ((f (lambda x x)))
 (f))
=> ()

In these 2 examples the procedure named f accepts any number
of arguments. These arguments are automatically formed into a list to which
the variable x is bound; the value of f is this list. 

--------

3. The value of the procedure g is a list whose 1st element is the
first argument and whose second element is a list containing the
remaining arguments. 

(let ((g (lambda (x . y) (list x y))))
 (g 1 2 3 4))
=> (1 (2 3 4))

4. The procedure h seperates out the second argument.  

(let ((h (lambda (x y . z) (list x y z))))
 (h 'a 'b 'c 'd))
=> (a b (c d))

---------------------------------------------------------------
Exercises:

1. Determine the value of the expressions. 

	a. (let ((f (lambda (x) x)))
		(f 'a))
	a) a

	b. (let ((f (lambda x x)))
		(f 'a))
	b) (a) 

	c. (let ((f (lambda (x . y) x)))
		(f 'a))
	c) a

	d. (let ((f (lambda (x . y) y)))
		(f 'a))
	d) ()

2. List the variables that occur free in each of the lambda 
expressions below. Do not omit variables that name primitive 
procedures such as + or cons. 

	a. (lambda (f x) (f x))
	a) none

	b. (lambda (x) (+ x x))
	b) +

	c. (lambda (x y) (f x y))
	c) f

	d. (lambda (x)
		(cons x (f x y)))
	d) const, f, y

	e. (lambda (x)
		(let ((z (cons x y)))
		 (x y z)))
	e) cons and z

	f. (lambda (x) 
		(let ((y (cons x y)))
		 (x y z)))
	f) cons, y, z

